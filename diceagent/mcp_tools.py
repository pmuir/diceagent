# AUTOGENERATED FILE: DO NOT EDIT
# Generated by the AgentRegistry CLI.

import json
import os
import re
from pathlib import Path
from typing import List, Optional, Union

from google.adk.tools.base_toolset import ToolPredicate
from google.adk.tools.mcp_tool.mcp_toolset import MCPToolset, StreamableHTTPConnectionParams


_MCP_SERVERS = [
]


def _resolve_env_vars(value: str) -> str:
    """Resolve ${VAR} placeholders using the local environment."""

    def replace_var(match):
        var_name = match.group(1)
        return os.environ.get(var_name, match.group(0))

    return re.sub(r"\$\{([^}]+)\}", replace_var, value)


def _get_terminate_on_close() -> bool:
    """Get the terminate_on_close setting from environment variable.
    
    Defaults to True for backward compatibility.
    Set MCP_TERMINATE_ON_CLOSE=false for stateless MCP servers.
    """
    return os.environ.get("MCP_TERMINATE_ON_CLOSE", "true").lower() != "false"


def _load_runtime_mcp_servers() -> List[dict]:
    """Load MCP servers resolved at runtime (registry types) from config file."""
    # The agent-specific directory is mounted to /config, so the file is at /config/mcp-servers.json
    config_paths = [Path(__file__).parent / "mcp-servers.json", Path("/config/mcp-servers.json")]
    
    # Allow override via environment variable for testing/debugging
    env_path = os.environ.get("MCP_SERVERS_CONFIG_PATH")
    if env_path:
        config_paths.insert(0, Path(env_path))
    
    for config_path in config_paths:
        if not config_path.exists():
            continue
        try:
            with open(config_path, "r") as f:
                data = json.load(f)
                if isinstance(data, list):
                    return data
                elif isinstance(data, dict) and "servers" in data:
                    return data["servers"]
        except (json.JSONDecodeError, IOError):
            continue
    
    return []


def _get_all_mcp_servers() -> List[dict]:
    """Get all MCP servers, merging baked-in and runtime-resolved servers."""
    servers = list(_MCP_SERVERS)  # Only command/remote servers (registry filtered out at template time)
    
    # Load runtime-resolved servers (registry types)
    runtime_servers = _load_runtime_mcp_servers()
    
    # Append runtime servers, avoiding duplicates by name
    existing_names = {s.get("name") for s in servers}
    for runtime_server in runtime_servers:
        server_name = runtime_server.get("name")
        if server_name and server_name not in existing_names:
            servers.append(runtime_server)
            existing_names.add(server_name)
    
    return servers

def get_mcp_tools(
    server_names: Optional[List[str]] = None,
    server_filters: Optional[Union[ToolPredicate, List[str]]] = None,
    global_filter: Optional[Union[ToolPredicate, List[str]]] = None,
) -> List[MCPToolset]:
    """Return MCP toolsets for the configured servers.
    
    Environment variables:
        MCP_TERMINATE_ON_CLOSE: Set to "false" for stateless MCP servers.
            Defaults to "true" for backward compatibility.
    """

    servers = _get_all_mcp_servers()

    if server_names is not None:
        servers = [s for s in servers if s.get("name") in server_names]

    terminate_on_close = _get_terminate_on_close()

    toolsets = []
    for server in servers:
        server_name = server["name"]
        url = f"http://{server_name}:3000/mcp" if server["type"] == "command" else server["url"]

        headers = {}
        if "headers" in server and server["headers"]:
            for key, value in server["headers"].items():
                headers[key] = _resolve_env_vars(value)

        predicate = None
        if server_filters and server_name in server_filters:
            predicate = server_filters[server_name]
        elif global_filter is not None:
            predicate = global_filter

        if headers:
            connection_params = StreamableHTTPConnectionParams(
                url=url, headers=headers, terminate_on_close=terminate_on_close
            )
        else:
            connection_params = StreamableHTTPConnectionParams(
                url=url, terminate_on_close=terminate_on_close
            )

        if predicate is not None:
            toolset = MCPToolset(connection_params=connection_params, tool_filter=predicate)
        else:
            toolset = MCPToolset(connection_params=connection_params)

        toolsets.append(toolset)

    return toolsets

